[{"title":"JavaScript 红宝书整理--继承","date":"2017-03-18T16:16:06.342Z","path":"2017/03/19/继承/","text":"继承 #1 原型链的详细分析 可看此章节接下来说说其他类型的继承 OO语言 |- 接口继承: 只继承方法签名 |- 实现继承: 继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而实现继承主要是依靠原型链来实现。 继承： 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承 JavaScript主要通过原型链实现继承。使用最多的是组合继承。原型链：通过将一个类型的实例赋值给另一个构造函数的原型实现。（问题对象实例共享所有继承的属性和方法，不适宜单独使用）借用构造函数： 在子类型构造函数的内部调用超类型构造函数。（每个实例都具有自己的属性） 组合继承： 使用原型链继承共享的属性和方法，通过借用构造函数继承实例属性。 原型式继承：可以不必预先定义构造函数的情况下继承（执行对给定对象的浅复制，复制得到的副本还可以进一步改造） 寄生式继承：与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，返回对象。（为了解决组合继承由于多次调用超类构造函数而导致低效率问题，可将这个模式与组合继承一起使用。） 寄生组合式继承：集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。 原型链详情看之前的文章 缺点： 包含引用类型值的原型。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。（没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数） 借用构造函数优点： 解决原型中包含引用类型值带来的问题。 可以在子类型构造函数中向超类型构造函数传递参数。 思想：在子类构造函数内部调用超类构造函数。通过apply()和call()方法可以在新建的对象上执行构造函数。 123456789101112131415161718function Animal()&#123; this.colors = [\"red\",\"blue\"];&#125;function Dog()&#123; //继承Animal Animal.call(this);&#125;var xiaohuang = new Dog();xiaohuang.colors.push(\"yellow\");console.log(xiaohuang.colors): // [\"red\",\"blue\",\"yellow\"]var xiaohei = new Dog();xiaohei .colors.push(\"black\");console.log(xiaohei .colors); // [\"red\",\"blue\",\"black\"]//Dog的每个实例都会有自己的colors属性副本 12345678910111213141516//传递参数//优点：在子类构造函数中向父类构造函数传递参数（相比于原型链的优点）function Animal(name)&#123; this.name = name;&#125;function Dog()&#123; //继承Animal,同时还传递了参数 Animal.call(this,\"xiaohuang\"); this.age = 10; //实例属性&#125;var xiaohuang = new Dog();console.log(xiaohuang .name); //\"xiaohuang”console.log(xiaohuang .age); //10 缺点： 构造函数模式存在的问题—方法都在构造函数中定义，函数复用无从谈起。 在超类型的原型中定义的方法，在子类型是不可见的。 结果所有的类型都只能使用构造函数模式借用构造函数很少单独使用 组合继承组合继承/伪经典继承--最常用的继承模式 优点： 将原型链和借用构造函数组合到一起，发挥两者之长。 思想： 使用原型链实现对原型属性和方法的继承，(实现了函数的复用) 通过借用构造函数实现对实例属性的继承 (保证每个实例都有自己的属性) 12345678910111213141516171819202122232425262728293031function Animal(name)&#123; this.name = name; this.colors = [\"red\",\"blue\"];&#125;Animal.prototype.getName = function()&#123; console.log(this.name);&#125;function Dog(name,age)&#123; //继承属性 Animal.call(this,name); this.age = age;&#125;Dog.prototype = new Animal();Dog.prototype.constructor = Dog;Dog.prototype.getAge = function()&#123; console.log(this.age);&#125;var xiaohuang = new Dog(\"xiaohuang\",10);xiaohuang.colors.push(\"yellow\");console.log(xiaohuang.colors); //\"red\",\"blue\",\"yellow\"xiaohuang.getAge(); //10xiaohuang.getName(); //\"xiaohuang\"var xiaohei = new dog(\"xioahei\",3);console.log(xiaohei.colors); //\"red\",\"blue\"xiaohei.getAge(); //3xiaohei.getName(); //\"xioahei\" 解释：animal的构造函数定义了name和colors两个属性 dog的原型定义了getName()方法。dog构造函数在调用animal构造函数时传入了name参数，又定义了自己的属性age 将animal实例的赋值给dog的原型，又在新原型上添加方法getAge(),两个不同的实例可以分别拥有自己的属性name，colors，又可以使用相同的方法getName() instanceof，isPrototypeOf()也能够识别基于组合继承创建的对象。 缺点： 无论什么情况下，都会调用两次超类型构造函数。(1.创建子类原型的时候 2.子类型构造函数内部) 看 寄生组合式继承 有两组 name和colors属性，dog的原型中有，dog的实例中有，实例中会屏蔽原型的的两个同名属性。 原型式继承思想：没有严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。必须要有一个对象可以作为另一个对象的基础。 12345678910111213141516171819202122function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F();&#125;;//object对传入的对象进行了一次浅复制var xiaoming = &#123; name : \"xiaoming\", friends : [\"f1\",\"f2\"]&#125;;var xiaohong = object(xiaoming);xiaohong.__proto__ === xiaoming; //truexiaohong.name = \"xiaohong\";xiaohong.friends.push(\"f3\");var xiaohua = \"xiaohua\";xiaohua.friends.push(\"f4\");console.log(xiaoming.friends);//[\"f1\",\"f2\",\"f3\",\"f4\"] 缺点 : 和原型模式一样，包含引用类型值的属性始终都会共享相应的值 寄生式继承思路：与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象。 1234567891011121314151617function createAnother(o)&#123; var clone = object(o); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象&#125;var person = &#123; name : \"fangfang\", friends : [\"f1\",\"f2\"]&#125;;var anotherperson = createAnother(person);anotherperson.sayhi(); //\"hi\"//anotherperson具有person的所有属性和方法，还有自己的sayhi方法 缺点：适用场景：在主要考虑对象，而不是自定义类型和构造函数的情况 寄生组合式继承最理想的继承方式 优点： 不必为了指定子类型的原型而调用父类型的构造函数（解决了组合继承至少两次调用超类构造函数）(只调用了一次animal构造函数，避免了dog.prototype上面创建多余的属性)(还能正常使用instanceof和isPrototypeOf()) 思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 不必为了指定子类型的原型而调用父类型的构造函数，我们所需的只是父类原型的一个副本。就是使用寄生式继承来继承父类的原型，然后将结果指定给子类型的原型 1234567891011121314151617181920212223242526function inheritPrototype(Dog,Animal)&#123; var prototype = Object(Animal.prototype); //创建父类原型的一个副本 prototype.constructor = Dog; //副本添加constructor属性 Dog.prototype = prototype; //把副本赋值给子类原型&#125;function Animal(name)&#123; this.name = name; this.colors = [\"red\",\"blue\"];&#125;Animal.prototype.getName = function()&#123; console.log(this.name);&#125;function Dog(name,age)&#123; Animal.call(this,name); this.age = age;&#125;inheritPrototype(Dog,Animal);Dog.prototype.getAge = function()&#123; console.log(this.age);&#125;//此时 Animal.prototype === Dog.prototype","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"Web","slug":"Web","permalink":"//guifzhang.me/tags/Web/"}]},{"title":"JavaScript 原型链分析","date":"2017-03-18T15:54:59.040Z","path":"2017/03/18/prototype/","text":"对象要清楚原型链,首先要弄清楚对象： 普通对象 最普通的对象：有proto属性（指向其原型链），没有prototype属性。 原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）) 函数对象： 凡是通过new Function()创建的都是函数对象。拥有proto、prototype属性（指向原型对象）。Function、Object、Array、Date、String、自定义函数 特例： Function.prototype(是原型对象，却是函数对象，下面会有解释) 1234//函数对象 function f1()&#123;&#125;; var f2 = function()&#123;&#125;; var f3 = function(\"n1\",\"n2\",\"return n1+n2\"); 12345678910111213141516171819202122console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof Object); //function console.log(typeof Array); //function console.log(typeof String); //function console.log(typeof Date); //function console.log(typeof Function); //function ``` ![10](https://cloud.githubusercontent.com/assets/14739234/23469011/5dff439a-fedd-11e6-8e84-7841368f64af.png)Array是函数对象，是Function的实例对象，Array是通过newFunction创建出来的。因为Array是Function的实例，所以Array.__proto__ === Function.prototype```JavaScript//普通对象 var o1 = new f1(); var o2 = &#123;&#125;; var o3 = new Object(); console.log(typeof o1); //Object console.log(typeof o2); //Object console.log(typeof o3); //Object 原型对象每创建一个函数都会有一个prototype属性，这个属性是一个指针，指向一个对象（通过该构造函数创建实例对象的原型对象）。原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。 第一块中有提到，原型对象属于普通对象。Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。123456function person()&#123;&#125;; console.log(typeof person.prototype) //Object console.log(typeof Object.prototype) // Object console.log(typeof Function.prototype) // 特殊 Function console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性 解释： 其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。 1234567function person()&#123;&#125;; var temp = new person(); person.prototype = temp; function Function()&#123;&#125;; var temp = new Function(); Function.prototype = temp; //由new Function()产生的对象都是函数对象 从一张图看懂原型对象、构造函数、实例对象之间的关系 1234567891011121314function Dog()&#123;&#125;; Dog.prototype.name = \"小黄\"; Dog.prototype.age = 13; Dog.prototype.getAge = function()&#123; return this.age; &#125; var dog1 = new Dog(); var dog2 = new Dog(); dog2.name = \"小黑\"; console.log(dog1.name); // 小黄 来自原型 console.log(dog2.name); // 小黑 来自实例 1234567891011121314//图中的一些关系 dog1.__proto__ === Dog.prototype Dog.prototype.__proto__ === Object.prototype //继承Object 下面原型链说 dog1.__proto__.__proto__ === Object.prototype Dog.prototype.constructor === Dog Dog.prototype.isPrototypeOf(dog1) //获取对象的原型 dog1.__proto__ //不推荐 Object.getPrototypeOf(dog1) === Dog.prototype //推荐 原型链原型链是实现继承的主要方法。 先说一下继承，许多OO语言都支持两张继承方式：接口继承、实现继承。 |- 接口继承：只继承方法签名 |- 实现继承：继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而实现继承主要是依靠原型链来实现。 原型链基本思路： 利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructor)，而实例对象都包含一个指向原型对象的内部指针(proto)。如果让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针(proto)，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实例与原型的链条。 原型链基本思路（图解）： 举例说明： 1234567891011121314151617function animal()&#123; this.type = \"animal\"; &#125; animal.prototype.getType = function()&#123; return this.type; &#125; function dog()&#123; this.name = \"dog\"; &#125; dog.prototype = new animal(); dog.prototype.getName = function()&#123; return this.name; &#125; var xiaohuang = new dog(); `` 12345//原型链关系 xiaohuang.__proto__ === dog.prototype dog.prototype.__proto__ === animal.prototype animal.prototype.__proto__ === Object.prototype Object.prototype.__proto__ === null 图解: 详细图: 从xiaohuang这个实例，看出整个链条: 总结： Xiaohuang这个Dog的实例对象继承了Animal，Animal继承了Object。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"Web","slug":"Web","permalink":"//guifzhang.me/tags/Web/"}]}]