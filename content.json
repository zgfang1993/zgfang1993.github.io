[{"title":"JavaScript 红宝书整理--函数","date":"2017-03-19T14:28:21.409Z","path":"前端札记/2017/03/19/函数.html","text":"函数 定义函数 递归 闭包 模仿块级作用域 私有变量 定义函数1.函数声明12function funname(arg1,arg2)&#123;&#125; 1funname.name === \"funname\" 非标准的name属性，等于function后面的标识符只在Firefox、Safari、Chrome、Opera有效 函数声明提升执行代码之前会先读取函数声明函数声明可以放在调用它的语句后面 2.函数表达式12var funname = function(arg1,arg2)&#123;&#125; 在使用前必须先赋值 递归 定义: 函数通过名字调用自身1234567function factorial(n)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return n * factorial(n-1); &#125;&#125; 问题:123var factorial1 = factorial;factorial = null;factorial1(4); //报错 解决：arguments.callee()指针：指向正在执行的函数 1234567function factorial(n)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return n * arguments.callee(n-1); &#125;&#125; 解决(严格模式):严格模式下，不能访问 arguments.callee可以使用 命名函数表达式创建名为f()的命名函数表达式 1234567var factorial = (function f(n)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return n * f(n-1); &#125;&#125;) 闭包1.定义：有权访问另一个函数作用域中的变量的函数。创建闭包常见方式：在一个函数内部创建另一个函数。 2.本质：一个指向变量对象的指针列表，只引用不包含变量对象 一般而言：函数执行完毕后，局部活动对象会被销毁 内存中仅保存全局作用域(全局执行环节的变量对象) 但是在闭包中：在另一个函数内部定义的函数将会把外部函数的活动对象添加到它的作用域中。外部函数返回内部匿名函数后执行完毕，但外部函数的活动对象并没有被销毁，因为匿名函数的作用域链中还在引用这个活动对象。即外部函数的执行环境的作用域链会被销毁，但它的活动对象仍然会在内存中。 12345678910111213141516function createComparisonFunction(propertyName)&#123; return function(obj1,obj2)&#123; var val1 = obj1[propertyName]; var val2 = obj2[propertyName]; if(val1&lt;val2)&#123; return -1; &#125;else if(val1&gt;val2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;var result = createComparisonFunction(\"name\")(&#123;name:\"A\"&#125;,&#123;name:\"B\"&#125;) [\"name\"] 解释：匿名函数从createComparisonFunction()函数中返回后，它的作用域链初始化为：包含的createComparisonFunction()函数的活动对象和全局变量对象。匿名函数可以访问在createComparisonFunction()中定义的所有变量。在createComparisonFunction()执行完毕后，其活动对象也不会被销毁（因为匿名函数的作用域链仍然在引用这个活动对象）。即：createComparisonFunction()执行完毕后，其执行环境的作用域链会被销毁，但它的活动对象任然会留在内存中，直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。图解： 12345var compareNames = createComparisonFunction(\"name\");var result = compareNames(&#123;name:\"A\"&#125;,&#123;name:\"B\"&#125;);//解除对匿名函数的引用，释放内存compareNames = null; 将compareNames设置为null，解除对该函数的引用等于通知垃圾回收例程将其清楚，匿名函数的作用域链被销毁，其他作用域也都销毁了。 慎重使用闭包：由于闭包会携带包含它的函数的作用域，会占用更多的内存。 3.副作用1）闭包与变量闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量 1234567891011function createArr()&#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = function()&#123; return i; &#125; &#125; return res;&#125;createArr()[0](); //10 每个函数返回的都是10 解决方法：没有直接把闭包赋值给数组，而是定义了一个匿名函数，并立即执行匿名函数，将结果赋值给数组 12345678910111213function createArr()&#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = (function(num)&#123; return function()&#123; return num; &#125;; &#125;)(i); &#125; return res;&#125;createArr()[0](); //0 2） this对象 匿名函数的执行环境具有全局性，因此其this对象通常指向window 123456789101112var name = \"window\";var obj = &#123; name:\"obj\"; getName:function()&#123; return function()&#123; //闭包 return this.name; &#125; &#125;&#125;obj.getName()(); //\"window\" 非严格模式 为什么匿名函数没有取得外部作用域的this对象解释：每个函数在被调用时都会自动取得两个特殊变量：this和arguments内部函数在搜索到这两个变量时，只会搜索到其活动对象为止。永远也不会直接访问外部函数的这两个变量。 解决：把外部作用域中的this对象保存在一个闭包能够访问的变量里。arguments也同理。 1234567891011121314var name = \"window\";var obj = &#123; name:\"obj\"; getName:function()&#123; var that = this; //保存在一个闭包能够访问的变量里 return function()&#123; //闭包 return that.name; &#125; &#125;&#125;obj.getName()(); //\"obj\" 特殊情况：2.加上括号，好像引用一个函数，但是this值得到了维持，obj.getName 和(obj.getName)的定义时一样的。3.先执行了一条赋值语句，再调用赋值后的结果。赋值表达式的值是函数本身，所以this值不能得到维持。1234567891011//特殊情况：var name = \"window\";var obj = &#123; name:\"obj\"; getName:function()&#123; return this.name; &#125;&#125; obj.getName(); //\"obj\" (obj.getName)(); //\"obj\" this值得到了维持(obj.getName = obj.getName)(); //\"window\" this值不能得到维持。 3) 内存泄露原因：JScript对象和COM对象使用不同的垃圾收集例程（IE9之前版本） 结果：闭包在IE9之前的版本，如果闭包的作用域链中保存着一个HTML元素，该元素将会无法被销毁。 举例： 123456function assignHandler()&#123; var element = document.getElementById(\"ele\"); element.onclick = function()&#123; //闭包 console.log(element.id); &#125;&#125; 这个闭包创建了一个循环引用，闭包保存了对assignHandler()的活动对象的引用，就会导致无法减少element的引用数。只要闭包存在，element的引用数至少是1，它占用的内存就会永远不被回收。 解决：12345678function assignHandler()&#123; var element = document.getElementById(\"ele\"); var id = element.id; element.onclick = function()&#123; //闭包 console.log(id); &#125; element = null;&#125; 解除对DOM对象的引用，减少引用数，确保正常回收其占用的内存。 把element.id保存在一个变量中，在闭包中引用该变量，消除了循环引用。 element设置为null。闭包会引用外部函数的整个活动对象，即使闭包不直接引用element，外部函数的活动对象也会保存一个引用 模仿块级作用域1. JS没有块级作用域123456function nums(count)&#123; for(var i=0;i&lt;count;i++)&#123; console.log(i); &#125; console.log(i);&#125; 在JavaScript中，变量i在for循环结束后没有被销毁。变量i是定义在nums()的活动对象，可以在函数内部随处访问。 1234567function nums(count)&#123; for(var i=0;i&lt;count;i++)&#123; console.log(i); &#125; var i; //重新声明变量 console.log(i);&#125; 即使重新声明同一个变量，也不会改变。会对后续的声明视而不见。 2. 匿名函数模仿块级作用域(私有作用域)1234567891011(function()&#123;//跨级作用域&#125;)();function nums(count)&#123; (function()&#123; for(var i=0;i&lt;count;i++)&#123; console.log(i); &#125; &#125;)(); console.log(i); //错误&#125; 在for循环外部插入了私有作用域，在匿名函数中定义的变量都会在执行结束时被销毁 经常在全局作用域中被用在函数外部。 创建私有作用域，限制了向全局作用域中添加过多的变量和函数。 较少闭包占用内存，没有指向匿名函数的引用，函数执行完毕立即销毁作用域链。 私有变量1. 定义任何在函数中定义的变量（参数、局部变量、函数内部定义的函数） 2. 特权方法访问私有变量的公有方法，创建闭包1234567891011121314function obj()&#123; //私有变量和私有函数 var variable = 10; function fun()&#123; return false; &#125; //特权方法 this.public = function()&#123; variable++; return fun(); &#125;&#125;//除了使用public()这个途径没有其他方法可以直接访问variable和fun(). 12345678function Dog()&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(val)&#123; name = val; &#125;&#125; 私有变量name在每个Dog实例中都不相同，每次调用构造函数都会重新创建这两个方法。 缺点：必须使用构造函数模式，会针对每个实例都创建同样一组方法。解决方法：静态私有变量 3. 静态私有变量1234567891011121314(function()&#123; //私有变量和私有函数 var variable = 10; function fun()&#123; return false; &#125; //构造函数 全局变量 非严格模式 obj = function()&#123;&#125;; //公有/特权方法 obj.prototype.public = function()&#123; variable++; return fun(); &#125;&#125;)() 创建了一个私有作用域 公有方法在原型上定义 构造函数使用函数表达式 构造函数申明没有用var(初始化未经声明的变量，会创建一个全局变量 非严格模式)5.私有变量和函数是由所有实例共享的 12345678910111213(function()&#123; var name = \"\"; Dog = function(val)&#123; name = val; &#125; this.prototype.getName = function()&#123; return name; &#125;; this.prototype.setName = function(val)&#123; name = val; &#125;&#125;)() 一个实例上调用setName会影响所有实例。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"红宝书","slug":"红宝书","permalink":"//guifzhang.me/tags/红宝书/"}]},{"title":"JavaScript 红宝书整理--事件","date":"2017-03-19T14:24:58.745Z","path":"前端札记/2017/03/19/事件.html","text":"事件流 事件冒泡（常用） 事件捕获（少用） DOM事件流 事件冒泡 事件开始由最具体的元素接收,逐级向上传播到不具体的节点(文档) 元素 → html → document 事件捕获 不太具体的元素更早接收事件，最具体的元素最后接收事件document →html →具体元素 DOM事件流 事件捕获阶段 → 处于目标阶段 → 事件冒泡阶段捕获阶段不会涉及事件目标 事件处理程序 HTML事件处理程序（不推荐） DOM0级事件处理程序 DOM2级事件处理程序 IE事件处理程序 跨浏览器的事件处理程序 事件对象 DOM中的事件对象 IE中的事件对象 跨浏览器的事件对象 事件类型 UI事件 焦点事件 鼠标与滚轮事件 键盘与文本事件 复合事件 变动事件 HTML5事件 设备事件 触摸与手势事件 内存和性能 事件委托 移除事件处理程序 模拟事件 DOM中的是事件模拟 IE中的事件模拟 事件处理程序1. HTML事件处理程序（不推荐）12&lt;a href=\"\" onclick=\"showMessage()\"&gt;&lt;/a&gt; 调用&lt;a href=\"\" onclick=\"alert('clicked')\"&gt;&lt;/a&gt; 转义 缺点： 1. 时差问题。&lt;a href=&quot;&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot;&gt;&lt;/a&gt; 2. 扩展事件处理程序的作用域链在不同的浏览器中会导致不同结果 3. HTML和JavaScript代码紧密耦合。 2.DOM0级事件处理程序通过JavaScript指定事件处理程序的传统方式：将一个函数赋值给一个事件处理程序属性。 必须要获取一个操作对象的引用。 优点： 简单 跨浏览器 每个元素都有自己的事件处理程序属性（onclick），将这个属性设置为一个函数，就可以指定事件处理程序。1234var btn = document.getElementById(\"btn\");通过文档对象获取按钮的引用btn.onclick = function()&#123; 指定onclick事件处理程序 alert(1);&#125; 使用DOM0级指定的事件处理程序被认为是元素的方法事件处理程序是在元素的作用域中运行 this引用当前元素1234var btn = document.getElementById(\"btn\");btn.onclick = function()&#123; alert(this.id); //\"btn\"&#125; 可以通过this访问元素的任何属性和方法会在事件流的冒泡阶段被处理 删除事件处理程序属性的值btn.onclick = null; //删除事件处理程序 3.DOM2级事件处理程序指定事件处理程序：addEventListener(事件名,事件处理程序的函数,布尔值)删除事件处理程序：removeEventListener(事件名,事件处理程序的函数,布尔值)true：在捕获阶段调用事件处理程序false：在冒泡阶段调用事件处理程序（默认） 通过addEventListener()添加的事件只能通过removeEventListener()来移除。移除时传入的参数与添加处理程序时使用的参数相同。（通过addEventListener()添加的匿名函数无法移除） 1234567var btn = document.getElementById(\"btn\");btn.addEventListener(\"click\",function()&#123; alert(this.id);&#125;,false);btn.addEventListener(\"click\",function()&#123; alert(“可以添加多个事件处理程序”);&#125;,false); 1234567891011//移除匿名函数没有用btn. removeEventListener (\"click\",function()&#123; alert(this.id);&#125;,false);//有效var btn = document.getElementById(\"btn\");var handler = function()&#123; alert(this.id);&#125;btn.addEventListener(\"click\",handler,false);btn.removeEventListener(\"click\",handler,false); 优点： 1.可以添加多个事件处理程序，按照添加顺序触发。 4. IE事件处理程序指定事件处理程序：attachEvent(事件名,事件处理程序的函数)删除事件处理程序：detachEvent(事件名,事件处理程序的函数) IE8及之前版本只支持事件冒泡，通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段 12345var btn = document.getElementById(\"btn\");btn.attachEvent(\"onclick\",function()&#123; alert(this === window); //true&#125;)匿名函数不能被移除 区别： 1．事件处理程序会在全局作用域中运行。 2．按照相反的添加顺序触发。 优点：1.可以添加多个事件处理程序，按照相反的添加顺序触发。支持IE事件处理程序的浏览器：IE Opera 5. 跨浏览器的事件处理程序 1.使用隔离浏览器差异的JavaScript库 2.自己开发（使用能力检测），只需关注冒泡阶段。 第一步：创建方法addHandler(元素,事件名称,事件处理程序函数) 第二步：创建方法removeHandler(元素,事件名称,事件处理程序函数) 第三步：创建对象EventUtil 1234567891011121314151617181920var EventUtil = &#123; addHandler:function(element,name,handler)&#123; if(element.addEventListener)&#123; //DOM2级事件处理程序 element.addEventListener(name,handler,false); &#125; else if(element.attachEvent)&#123; //IE事件处理程序 element.attachEvent(\"on\"+name,handler); &#125; else &#123; element[\"on\"+name] = handler; //DOM0级事件处理程序 &#125; &#125;, removeHandler:function(element,name,handler)&#123; if(element.removeEventListener)&#123; //DOM2级事件处理程序 element.removeEventListener(name,handler,false); &#125; else if(element.detachEvent)&#123; //IE事件处理程序 element.detachEvent(\"on\"+name,handler); &#125; else &#123; element[\"on\"+name] = null; //DOM0级事件处理程序 &#125; &#125;&#125;; 1234567使用var btn = document.getElementById(\"btn\");var handler = function()&#123; alert(this.id);&#125;;EventUtil.addHandler(btn,\"click\",handler);EventUtil.removeHandler(btn,\"click\",handler); 没有考虑到所有浏览器问题（IE中作用域问题）DOM0级对每个事件只支持一个事件处理程序 事件对象1.DOM中的事件对象1234567var btn = document.getElementById(\"btn\");btn.onclick = function(event)&#123; alert(event.type); //\"click\"&#125;btn.addEventListener(\"click\",function()&#123; alert(event.type); //\"click\"&#125;,false); &lt;a href=&quot;&quot; onclick=&quot;alert(event.type)&quot;&gt;&lt;/a&gt; Event属性和方法：触发的事件类型不一样，属性和方法不一样具体看附件。bubblescancelablecurrentTargetdefaultPreventeddetaileventPhase preventDefault()stopImmediatePropagation()stopPropagation()targettrustedtypeview 12345document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body);//true alert(event.target === document.body.getElementById(\"btn\"));//true&#125; 12345678910111213141516//处理多个事件var btn = document.getElementById(\"btn\");var handler = function (event) &#123; switch (event.type)&#123; case \"click\": alert(\"click\"); break; case \"mouseover\": event.target.style.backgroundColor = \"red\"; break; case \"mouseout\": event.target.style.backgroundColor = \"\"; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 123456// preventDefault()阻止特定事件的默认行为 //只有cancelable属性为true才可以var link = document.getElementById(\"link\");link.onclick = function(event)&#123; event.preventDefault(); //阻止点击链接的默认行为&#125; 123456789//stopPropagation()立即停止事件在DOM层次中的传播，取消进一步的事件捕获或冒泡。var btn = document.getElementById(\"btn\");btn.onclick = function (event) &#123; alert(\"clicked\"); event.stopPropagation(); //click事件不会传到document.body 避免触发注册在document.body上的事件处理程序&#125;;document.body.onclick = function (event) &#123; alert(\"body clicked\");&#125; 123456789101112131415//eventPhase 确定事件当前正位于事件流的哪个阶段1- 捕获阶段2- 处于目标3- 冒泡阶段var btn = document.getElementById(\"btn\");btn.onclick = function (event) &#123; alert(event.eventPhase); //2&#125;;document.body.addEventListener(\"click\",function (event) &#123; alert(event.eventPhase); //1&#125;,true)document.body.onclick = function (event) &#123; alert(event.eventPhase); //3&#125; 只有在事件处理程序执行期间，event对象才存在；执行完即销毁。 2.IE中的事件对象 1.在使用DOM0级方式添加事件处理程序，event对象作为window对象的一个属性存在。 2.通过attachEvent()添加，会有一个event对象作为参数传入事件处理程序函数中。 3.通过HTML特性指定的事件处理程序，通过event变量来访问 12345678910111213//1. 使用DOM0级方式添加事件处理程序var btn = document.getElementById(\"btn\");btn.onclick = function () &#123; var event = window.event; alert(event.type); //\"click\"&#125;;//2. 通过attachEvent()添加事件处理程序var btn = document.getElementById(\"btn\");btn.attachEvent(\"onclick\",function (event) &#123; alert(event.type); //\"click\"&#125;)//3. 通过HTML特性指定的事件处理程序&lt;a href=\"\" onclick=\"alert(event.type)\"&gt;&lt;/a&gt; 12345678//事件处理程序的作用域是根据指定他的方式来确定的，this不会始终等于事件目标。var btn = document.getElementById(\"btn\");btn.onclick = function () &#123; alert(window.event.srcElement === this); //true&#125;;btn.attachEvent(\"onclick\",function (event) &#123; alert(event.srcElement === this); //false&#125;) 属性和方法cancelBubble →DOM stopPropagation()returnValue →DOM preventDefault()SRCElementtype 12345//returnValue 取消给定事件的默认行为var link = document.getElementById(\"link\");link.onclick = function()&#123; window.event.returnValue = false; //阻止点击链接的默认行为&#125; 123456789//cancelBubble立即停止事件在DOM层次中的传播，取消进一步的事件捕获或冒泡。var btn = document.getElementById(\"btn\");btn.onclick = function () &#123; alert(\"clicked\"); window.event.cancelBubble = true; //click事件不会传到document.body 避免触发注册在document.body上的事件处理程序&#125;;document.body.onclick = function () &#123; alert(\"body clicked\");&#125; 3.跨浏览器的事件对象DOM和IE中的event对象不同，IE中event对象的全部信息和方法DOM对象中都有，实现方式不同。 123456789101112131415161718192021222324252627var EventUtil = &#123; getEvent:function (event) &#123; return event ? event : window.event; &#125;, getTarget:function (event) &#123; return event.target || event.srcElement; &#125;, preventDefault:function (event) &#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125;, stopPropagation:function (event) &#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125; &#125;&#125;;//使用btn.onclick = function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);&#125; 内存和性能1.事件委托 事件委托：对事件处理程序过多问题的解决 利用事件冒泡，只指定一个事件处理程序就可以管理某一类的所有事件。 适合事件委托技术的事件：click、mousedown、mouseup、keydown、keyup、keypress 1234567891011121314151617var links = document.getElementById(\"links\");EventUtil.addForceTouchHandler(links,\"click\",function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch (target.id)&#123; case \"doSomething\": document.title = \"i changed the document's title\"; break; case \"goSomewhere\": document.href = \"http://www.baidu.com\"; break; case \"sayHi\": alert(\"hi\"); break; &#125;&#125;); 2. 移除事件处理程序 在不需要的时候移除事件处理程序 1.从文档中移除带有事件处理程序的元素时。 2.卸载页面的时候。 1.123456789&lt;div id=\"myDiv\"&gt; &lt;input type=\"button\" id=\"btn\"&gt;&lt;/div&gt; var btn = document.getElementById(\"btn\");btn.onclick = function () &#123; btn.onclick = null; //移除事件处理程序 document.getElementById(\"myDiv\").innerHTML = \"processing...\";&#125; 2.在卸载页面之前通过onunload事件处理程序移除所有事件处理程序。事件委托优点（需要跟踪的事件处理程序越少，移除越容易） 说说JQuery中的事件1. bind()直接绑定在元素上123$(\"ul li\").bind(\"click\", function () &#123; alert($(this).text());&#125;) 这里用了隐式迭代的方法，如果匹配到的元素特别多的时候，比如如果我在ul里放了50个li元素，就得执行绑定50次。对于大量元素来说，影响到了性能。但是如果是id选择器，因为id唯一，用bind()方法就很快捷了。 对于尚未存在的元素，无法绑定。(动态加载进来的元素) 随着DOM结构的复杂化和Ajax等动态脚本技术的运用，有了较多的动态添加进来的元素，直接用JQ添加click事件会发现新添加进来的元素并不能直接选取到，在这里就需要用到事件委托方法，JQ为事件委托提供了live（）、dalegate（）和on（）方法。 事件委托： DOM在为页面中的每个元素分派事件时，相应的元素一般都在事件冒泡阶段处理事件。在类似 body &gt; div &gt; a 这样的结构中，如果单击a元素，click事件会从a→div→body（即document对象）。因此，发生在a上面的单击事件，div和body元素同样可以处理。而利用事件传播（这里是冒泡）这个机制，就可以实现事件委托。具体来说，事件委托就是事件目标自身不处理事件，而是把处理任务委托给其父元素或者祖先元素，甚至根元素（document）。 2. live()12$(\"ul.list li\").live(\"click\",function()&#123; &#125;); // jQuery 1.3 缺点 $()函数会找到当前页面中的所有li元素并创建jQuery对象，但在确认事件目标时却不用这个li元素集合，而是使用选择符表达式与event.target或其祖先元素进行比较，因而生成这个jQuery对象会造成不必要的开销； 默认把事件绑定到$(document)元素(如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失) 只能放在直接选择的元素后面，不能在连缀的DOM遍历方法后面使用，即$(“ ul.list li “).live…可以，但$( ul.list”).find(“li”).live…不行 收集li元素并创建jQuery对象，但实际操作的却是$(document)对象. 解决： 避免生成不必要的jQuery对象123(function($)&#123; $(\"#info_table td\").live(\"click\",function()&#123; &#125;);&#125;)(jQuery); 前提：脚本必须是在页面的head元素中链接和(或)执行的“早委托”的hack，即在$(document).ready()方法外部调用.live()。这时候刚好document元素可用，而整个DOM还远未生成。这个匿名函数不会等到DOM就绪就会执行。 为了避免事件冒泡造成的性能损失 jQuery 1.4$(“li”,$(“ul.list”)[0]).live(“click”,function(){ });“受托方”就从默认的$(document)变成了$(“ul.list “)[0]，解决了“事件传播链”过长 为了解决无谓生成元素集合的问题，jQuery 1.4.2干脆直接引入了一个新方法delegate()。 3.delegate()12$(\"ul.list \").delegate(\"li\",\"click\",function()&#123; &#125;); 使用场景： 为DOM中的很多元素绑定相同事件； 为DOM中尚不存在的元素绑定事件； 优点： 直接将目标元素选择符（”li”）、事件（”click”）及处理程序与“受托方”$(“ul.list “)绑定，不额外收集元素、事件传播路径缩短、语义明确； 支持在连缀的DOM遍历方法后面调用， $(&quot;div &quot;).find(&quot;#list&quot;).delegate...支持精确控制 用事件委托时，如果注册到目标元素上的其他事件处理程序使用.stopPropagation()阻止了事件传播，那么事件委托就会失效。 4. on() off() jQuery 1.7其实是将以前的绑定事件方法作了统一12$('button').on('click',function()&#123;&#125;);$(div).on('click', 'button',function()&#123;&#125;); 如果指定selector，则为事件委托；否则，就是常规绑定。 1234//delegate源码 delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"红宝书","slug":"红宝书","permalink":"//guifzhang.me/tags/红宝书/"}]},{"title":"JavaScript 红宝书整理--继承","date":"2017-03-18T16:16:06.342Z","path":"前端札记/2017/03/19/继承.html","text":"继承 #1 原型链的详细分析 可看此章节接下来说说其他类型的继承 OO语言 |- 接口继承: 只继承方法签名 |- 实现继承: 继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而实现继承主要是依靠原型链来实现。 继承： 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承 JavaScript主要通过原型链实现继承。使用最多的是组合继承。原型链：通过将一个类型的实例赋值给另一个构造函数的原型实现。（问题对象实例共享所有继承的属性和方法，不适宜单独使用）借用构造函数： 在子类型构造函数的内部调用超类型构造函数。（每个实例都具有自己的属性） 组合继承： 使用原型链继承共享的属性和方法，通过借用构造函数继承实例属性。 原型式继承：可以不必预先定义构造函数的情况下继承（执行对给定对象的浅复制，复制得到的副本还可以进一步改造） 寄生式继承：与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，返回对象。（为了解决组合继承由于多次调用超类构造函数而导致低效率问题，可将这个模式与组合继承一起使用。） 寄生组合式继承：集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。 原型链详情看之前的文章 缺点： 包含引用类型值的原型。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。（没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数） 借用构造函数优点： 解决原型中包含引用类型值带来的问题。 可以在子类型构造函数中向超类型构造函数传递参数。 思想：在子类构造函数内部调用超类构造函数。通过apply()和call()方法可以在新建的对象上执行构造函数。 123456789101112131415161718function Animal()&#123; this.colors = [\"red\",\"blue\"];&#125;function Dog()&#123; //继承Animal Animal.call(this);&#125;var xiaohuang = new Dog();xiaohuang.colors.push(\"yellow\");console.log(xiaohuang.colors): // [\"red\",\"blue\",\"yellow\"]var xiaohei = new Dog();xiaohei .colors.push(\"black\");console.log(xiaohei .colors); // [\"red\",\"blue\",\"black\"]//Dog的每个实例都会有自己的colors属性副本 12345678910111213141516//传递参数//优点：在子类构造函数中向父类构造函数传递参数（相比于原型链的优点）function Animal(name)&#123; this.name = name;&#125;function Dog()&#123; //继承Animal,同时还传递了参数 Animal.call(this,\"xiaohuang\"); this.age = 10; //实例属性&#125;var xiaohuang = new Dog();console.log(xiaohuang .name); //\"xiaohuang”console.log(xiaohuang .age); //10 缺点： 构造函数模式存在的问题—方法都在构造函数中定义，函数复用无从谈起。 在超类型的原型中定义的方法，在子类型是不可见的。 结果所有的类型都只能使用构造函数模式借用构造函数很少单独使用 组合继承组合继承/伪经典继承--最常用的继承模式 优点： 将原型链和借用构造函数组合到一起，发挥两者之长。 思想： 使用原型链实现对原型属性和方法的继承，(实现了函数的复用) 通过借用构造函数实现对实例属性的继承 (保证每个实例都有自己的属性) 12345678910111213141516171819202122232425262728293031function Animal(name)&#123; this.name = name; this.colors = [\"red\",\"blue\"];&#125;Animal.prototype.getName = function()&#123; console.log(this.name);&#125;function Dog(name,age)&#123; //继承属性 Animal.call(this,name); this.age = age;&#125;Dog.prototype = new Animal();Dog.prototype.constructor = Dog;Dog.prototype.getAge = function()&#123; console.log(this.age);&#125;var xiaohuang = new Dog(\"xiaohuang\",10);xiaohuang.colors.push(\"yellow\");console.log(xiaohuang.colors); //\"red\",\"blue\",\"yellow\"xiaohuang.getAge(); //10xiaohuang.getName(); //\"xiaohuang\"var xiaohei = new dog(\"xioahei\",3);console.log(xiaohei.colors); //\"red\",\"blue\"xiaohei.getAge(); //3xiaohei.getName(); //\"xioahei\" 解释：animal的构造函数定义了name和colors两个属性 dog的原型定义了getName()方法。dog构造函数在调用animal构造函数时传入了name参数，又定义了自己的属性age 将animal实例的赋值给dog的原型，又在新原型上添加方法getAge(),两个不同的实例可以分别拥有自己的属性name，colors，又可以使用相同的方法getName() instanceof，isPrototypeOf()也能够识别基于组合继承创建的对象。 缺点： 无论什么情况下，都会调用两次超类型构造函数。(1.创建子类原型的时候 2.子类型构造函数内部) 看 寄生组合式继承 有两组 name和colors属性，dog的原型中有，dog的实例中有，实例中会屏蔽原型的的两个同名属性。 原型式继承思想：没有严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。必须要有一个对象可以作为另一个对象的基础。 12345678910111213141516171819202122function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F();&#125;;//object对传入的对象进行了一次浅复制var xiaoming = &#123; name : \"xiaoming\", friends : [\"f1\",\"f2\"]&#125;;var xiaohong = object(xiaoming);xiaohong.__proto__ === xiaoming; //truexiaohong.name = \"xiaohong\";xiaohong.friends.push(\"f3\");var xiaohua = \"xiaohua\";xiaohua.friends.push(\"f4\");console.log(xiaoming.friends);//[\"f1\",\"f2\",\"f3\",\"f4\"] 缺点 : 和原型模式一样，包含引用类型值的属性始终都会共享相应的值 寄生式继承思路：与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象。 1234567891011121314151617function createAnother(o)&#123; var clone = object(o); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象&#125;var person = &#123; name : \"fangfang\", friends : [\"f1\",\"f2\"]&#125;;var anotherperson = createAnother(person);anotherperson.sayhi(); //\"hi\"//anotherperson具有person的所有属性和方法，还有自己的sayhi方法 缺点：适用场景：在主要考虑对象，而不是自定义类型和构造函数的情况 寄生组合式继承最理想的继承方式 优点： 不必为了指定子类型的原型而调用父类型的构造函数（解决了组合继承至少两次调用超类构造函数）(只调用了一次animal构造函数，避免了dog.prototype上面创建多余的属性)(还能正常使用instanceof和isPrototypeOf()) 思想：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 不必为了指定子类型的原型而调用父类型的构造函数，我们所需的只是父类原型的一个副本。就是使用寄生式继承来继承父类的原型，然后将结果指定给子类型的原型 1234567891011121314151617181920212223242526function inheritPrototype(Dog,Animal)&#123; var prototype = Object(Animal.prototype); //创建父类原型的一个副本 prototype.constructor = Dog; //副本添加constructor属性 Dog.prototype = prototype; //把副本赋值给子类原型&#125;function Animal(name)&#123; this.name = name; this.colors = [\"red\",\"blue\"];&#125;Animal.prototype.getName = function()&#123; console.log(this.name);&#125;function Dog(name,age)&#123; Animal.call(this,name); this.age = age;&#125;inheritPrototype(Dog,Animal);Dog.prototype.getAge = function()&#123; console.log(this.age);&#125;//此时 Animal.prototype === Dog.prototype","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"红宝书","slug":"红宝书","permalink":"//guifzhang.me/tags/红宝书/"}]},{"title":"JavaScript 原型链分析","date":"2017-03-18T15:54:59.040Z","path":"前端札记/2017/03/18/原型链.html","text":"对象要清楚原型链,首先要弄清楚对象： 普通对象 最普通的对象：有proto属性（指向其原型链），没有prototype属性。 原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）) 函数对象： 凡是通过new Function()创建的都是函数对象。拥有proto、prototype属性（指向原型对象）。Function、Object、Array、Date、String、自定义函数 特例： Function.prototype(是原型对象，却是函数对象，下面会有解释) 1234//函数对象 function f1()&#123;&#125;; var f2 = function()&#123;&#125;; var f3 = function(\"n1\",\"n2\",\"return n1+n2\"); 12345678910111213141516171819202122console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof Object); //function console.log(typeof Array); //function console.log(typeof String); //function console.log(typeof Date); //function console.log(typeof Function); //function ``` ![10](https://cloud.githubusercontent.com/assets/14739234/23469011/5dff439a-fedd-11e6-8e84-7841368f64af.png)Array是函数对象，是Function的实例对象，Array是通过newFunction创建出来的。因为Array是Function的实例，所以Array.__proto__ === Function.prototype```JavaScript//普通对象 var o1 = new f1(); var o2 = &#123;&#125;; var o3 = new Object(); console.log(typeof o1); //Object console.log(typeof o2); //Object console.log(typeof o3); //Object 原型对象每创建一个函数都会有一个prototype属性，这个属性是一个指针，指向一个对象（通过该构造函数创建实例对象的原型对象）。原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。 第一块中有提到，原型对象属于普通对象。Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。123456function person()&#123;&#125;; console.log(typeof person.prototype) //Object console.log(typeof Object.prototype) // Object console.log(typeof Function.prototype) // 特殊 Function console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性 解释： 其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。 1234567function person()&#123;&#125;; var temp = new person(); person.prototype = temp; function Function()&#123;&#125;; var temp = new Function(); Function.prototype = temp; //由new Function()产生的对象都是函数对象 从一张图看懂原型对象、构造函数、实例对象之间的关系 1234567891011121314function Dog()&#123;&#125;; Dog.prototype.name = \"小黄\"; Dog.prototype.age = 13; Dog.prototype.getAge = function()&#123; return this.age; &#125; var dog1 = new Dog(); var dog2 = new Dog(); dog2.name = \"小黑\"; console.log(dog1.name); // 小黄 来自原型 console.log(dog2.name); // 小黑 来自实例 1234567891011121314//图中的一些关系 dog1.__proto__ === Dog.prototype Dog.prototype.__proto__ === Object.prototype //继承Object 下面原型链说 dog1.__proto__.__proto__ === Object.prototype Dog.prototype.constructor === Dog Dog.prototype.isPrototypeOf(dog1) //获取对象的原型 dog1.__proto__ //不推荐 Object.getPrototypeOf(dog1) === Dog.prototype //推荐 原型链原型链是实现继承的主要方法。 先说一下继承，许多OO语言都支持两张继承方式：接口继承、实现继承。 |- 接口继承：只继承方法签名 |- 实现继承：继承实际的方法 由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而实现继承主要是依靠原型链来实现。 原型链基本思路： 利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructor)，而实例对象都包含一个指向原型对象的内部指针(proto)。如果让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针(proto)，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实例与原型的链条。 原型链基本思路（图解）： 举例说明： 1234567891011121314151617function animal()&#123; this.type = \"animal\"; &#125; animal.prototype.getType = function()&#123; return this.type; &#125; function dog()&#123; this.name = \"dog\"; &#125; dog.prototype = new animal(); dog.prototype.getName = function()&#123; return this.name; &#125; var xiaohuang = new dog(); `` 12345//原型链关系 xiaohuang.__proto__ === dog.prototype dog.prototype.__proto__ === animal.prototype animal.prototype.__proto__ === Object.prototype Object.prototype.__proto__ === null 图解: 详细图: 从xiaohuang这个实例，看出整个链条: 总结： Xiaohuang这个Dog的实例对象继承了Animal，Animal继承了Object。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//guifzhang.me/tags/JavaScript/"},{"name":"红宝书","slug":"红宝书","permalink":"//guifzhang.me/tags/红宝书/"}]}]